package main

import (
	"github.com/jakecoffman/cron"
	"strconv"
	"time"
	"sync"
	"fmt"
)

type SchduleActiveCallback func(int, string)

type ScheduleJob struct {
	id       int
	msg      string
	callback SchduleActiveCallback
}

var g_scheduleManager *ScheduleManager

func (this *ScheduleJob) Run() {
	if nil != this.callback {
		this.callback(this.id, this.msg);
	}
}

type ScheduleManager struct {
	cronJob *cron.Cron
}

func (this *ScheduleManager) NewScheduleJob(_id int, _msg string, _job SchduleActiveCallback) *ScheduleJob {
	instance := &ScheduleJob{
		id:       _id,
		msg:      _msg,
		callback: _job,
	}
	return instance
}
func NewScheduleManager() *ScheduleManager {
	instance := &ScheduleManager{}
	instance.cronJob = cron.New()
	return instance
}

//export Start
func Start() {
	g_scheduleManager.cronJob.Start()
}

//export Stop
func Stop() {
	g_scheduleManager.cronJob.Stop()
}

//export AddJob
func AddJob(id int, msg string, scheduleExpr string, f SchduleActiveCallback) {
	job := g_scheduleManager.NewScheduleJob(id, msg, f)
	g_scheduleManager.cronJob.AddJob(scheduleExpr, job, strconv.Itoa(id))
}

//export RemoveJob
func RemoveJob(id int) {
	g_scheduleManager.cronJob.RemoveJob(strconv.Itoa(id))
}

//export Init
//func Init() {
//	g_scheduleManager = NewScheduleManager()
//}

const ONE_SECOND = 1*time.Second + 10*time.Millisecond

type testJob struct {
	wg   *sync.WaitGroup
	name string
}

func (t testJob) Run() {
	fmt.Println(t.name)
	t.wg.Done()
}

func main() {
	wg := &sync.WaitGroup{}
	wg.Add(1)

	g_scheduleManager = NewScheduleManager()
	cronJob := g_scheduleManager.cronJob

	// cron := New()
	//cronJob.AddJob("0 0 0 30 Feb ?", testJob{wg, "job0"}, "test19")
	//cronJob.AddJob("0 0 0 1 1 ?", testJob{wg, "job1"}, "test20")
	cronJob.AddJob("*/1 * * * * ?", testJob{wg, "job2"}, "test21")
	//cronJob.AddJob("1 0 0 1 1 ?", testJob{wg, "job3"}, "test22")
	cronJob.Schedule(cron.Every(5*time.Second+5*time.Nanosecond), testJob{wg,
		"job4"}, "test23")
	cronJob.Schedule(cron.Every(5*time.Minute), testJob{wg, "job5"}, "test24")

	cronJob.Start()
	defer cronJob.Stop()

	select {
	case <-time.After(ONE_SECOND):
		fmt.Printf("Fail Now!")
	case <-wait(wg):
	}

	// Ensure the entries are in the right order.
	//expecteds := []string{"job2", "job4", "job5", "job1", "job3", "job0"}
	//
	//var actuals []string
	//for _, entry := range cron.Entries() {
	//	actuals = append(actuals, entry.Job.(testJob).name)
	//}
	//
	//for i, expected := range expecteds {
	//	if actuals[i] != expected {
	//		t.Errorf("Jobs not in the right order.  (expected) %s != %s (actual)", expecteds, actuals)
	//		t.FailNow()
	//	}
	//}
}

func wait(wg *sync.WaitGroup) chan bool {
	ch := make(chan bool)
	go func() {
		wg.Wait()
		ch <- true
	}()
	return ch
}
